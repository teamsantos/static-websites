name: Deploy Projects (Optimized)
on:
  push:
    branches: [master]
    paths:
        - 'projects/**'
  workflow_dispatch:
    inputs:
      force_deploy_all:
        description: 'Force deploy all projects'
        required: false
        default: 'false'
      deploy_infrastructure:
        description: 'Deploy infrastructure (CloudFront, Route53)'
        required: false
        default: 'false'

env:
  S3_BUCKET: teamsantos-static-websites
  BUILD_DIR: dist

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      projects: ${{ steps.changed.outputs.projects }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch full history

      - id: changed
        run: |
          echo "Checking for changed projects..."
          echo "Before commit: ${{ github.event.before }}"
          echo "Current commit: ${{ github.sha }}"
          
          # Check if this is a manual dispatch with force deploy
          if [ "${{ github.event.inputs.force_deploy_all }}" == "true" ]; then
            echo "Force deploy all projects requested"
            CHANGED=$(find projects -maxdepth 1 -mindepth 1 -type d 2>/dev/null | cut -d/ -f2 | sort -u || echo "")
          elif [ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]; then
            # First push or new branch - check all project folders
            echo "First push detected, checking all projects"
            CHANGED=$(find projects -maxdepth 1 -mindepth 1 -type d 2>/dev/null | cut -d/ -f2 | sort -u || echo "")
          else
             # Check if both commits exist
             if git cat-file -e "${{ github.event.before }}" 2>/dev/null && git cat-file -e "${{ github.sha }}" 2>/dev/null; then
               echo "Both commits found, doing normal diff"
               # Get changed files, then filter to only directories
               CHANGED_FILES=$(git diff --name-only "${{ github.event.before }}" "${{ github.sha }}" 2>/dev/null \
                 | grep '^projects/' | cut -d/ -f2 | sort -u || echo "")

               # Filter to only directories
               CHANGED=""
               for item in $CHANGED_FILES; do
                 if [ -d "projects/$item" ]; then
                   CHANGED="$CHANGED $item"
                 fi
               done
               CHANGED=$(echo "$CHANGED" | xargs | sort -u || echo "")
             else
               echo "One or both commits not found, trying fallback methods..."
               # Try HEAD~1 comparison
               if git cat-file -e "HEAD~1" 2>/dev/null; then
                 echo "Using HEAD~1 comparison"
                 CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null \
                   | grep '^projects/' | cut -d/ -f2 | sort -u || echo "")

                 # Filter to only directories
                 CHANGED=""
                 for item in $CHANGED_FILES; do
                   if [ -d "projects/$item" ]; then
                     CHANGED="$CHANGED $item"
                   fi
                 done
                 CHANGED=$(echo "$CHANGED" | xargs | sort -u || echo "")
               else
                 # Last resort - deploy all projects
                 echo "Cannot determine changes, deploying all projects"
                 CHANGED=$(find projects -maxdepth 1 -mindepth 1 -type d 2>/dev/null | cut -d/ -f2 | sort -u || echo "")
               fi
             fi
          fi
          
           # If still no changes detected, force deploy all as fallback
           if [ -z "$CHANGED" ]; then
             echo "No changes detected, falling back to deploy all projects"
             CHANGED=$(find projects -maxdepth 1 -mindepth 1 -type d 2>/dev/null | cut -d/ -f2 | sort -u || echo "")
           fi

           # Final filter to ensure only directories are included
           FINAL_CHANGED=""
           for item in $CHANGED; do
             if [ -d "projects/$item" ]; then
               FINAL_CHANGED="$FINAL_CHANGED $item"
             fi
           done
           CHANGED=$(echo "$FINAL_CHANGED" | xargs | sort -u || echo "")
          
          # Convert to space-separated string for output
          CHANGED_STR=$(echo "$CHANGED" | tr '\n' ' ' | sed 's/[[:space:]]*$//')
          echo "Changed projects: $CHANGED_STR"
          echo "projects=$CHANGED_STR" >> $GITHUB_OUTPUT

  # Deploy infrastructure only if explicitly requested or on first deployment
  deploy-infrastructure:
    if: github.event.inputs.deploy_infrastructure == 'true'
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name == 'master' && 'production' || 'staging' }}
    container:
      image: ghcr.io/${{ github.repository_owner }}/static-websites:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install dependencies
        run: npm ci

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Install infra dependencies
        working-directory: infra
        run: |
          echo "Installing infra dependencies..."
          if ! npm ci 2>/dev/null; then
            echo "npm ci failed, falling back to npm install..."
            rm -rf node_modules package-lock.json
            npm install
          fi
          echo "‚úÖ Infra dependencies installed"

      - name: Install CDK CLI globally
        run: |
          echo "Installing CDK CLI globally..."
          npm install -g aws-cdk typescript ts-node
          echo "‚úÖ CDK CLI installed"

      - name: Check and bootstrap CDK
        id: check-bootstrap
        working-directory: infra
        run: |
          echo "Checking CDK bootstrap status..."
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          
          check_bootstrap() {
            local region=$1
            if aws cloudformation describe-stacks --region "$region" --stack-name CDKToolkit --query 'Stacks[0].StackStatus' --output text 2>/dev/null | grep -q "COMPLETE"; then
              echo "‚úÖ Region $region is bootstrapped"
              return 0
            else
              echo "‚ùå Region $region needs bootstrapping"
              return 1
            fi
          }
          
          BOOTSTRAP_NEEDED=""
          if ! check_bootstrap "us-east-1"; then
            BOOTSTRAP_NEEDED="$BOOTSTRAP_NEEDED us-east-1"
          fi
          if ! check_bootstrap "eu-south-2"; then
            BOOTSTRAP_NEEDED="$BOOTSTRAP_NEEDED eu-south-2"
          fi
          
          BOOTSTRAP_NEEDED=$(echo "$BOOTSTRAP_NEEDED" | xargs)
          echo "bootstrap-needed=$BOOTSTRAP_NEEDED" >> $GITHUB_OUTPUT
          echo "account-id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

      - name: Bootstrap CDK regions
        if: steps.check-bootstrap.outputs.bootstrap-needed != ''
        working-directory: infra
        run: |
          echo "Bootstrapping CDK for regions: ${{ steps.check-bootstrap.outputs.bootstrap-needed }}"
          ACCOUNT_ID="${{ steps.check-bootstrap.outputs.account-id }}"
          for region in ${{ steps.check-bootstrap.outputs.bootstrap-needed }}; do
            echo "Bootstrapping region: $region"
            CDK_DEFAULT_ACCOUNT=$ACCOUNT_ID CDK_DEFAULT_REGION=$region \
            npx cdk bootstrap "aws://$ACCOUNT_ID/$region" --require-approval never -c "projects=dummy"
          done

      - name: Build CDK project
        working-directory: infra
        run: |
          echo "Building CDK project..."
          npx tsc
          echo "‚úÖ CDK project built"

      - name: Deploy infrastructure
        working-directory: infra
        run: |
          echo "üöÄ Deploying multi-tenant infrastructure (this runs only once)"
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          CDK_DEFAULT_ACCOUNT=$ACCOUNT_ID CDK_DEFAULT_REGION=us-east-1 \
          npx cdk deploy MultiTenantDistribution StaticWebsitesBucket CreateProjectStack StripeCheckoutStack \
            --require-approval never --verbose
          echo "‚úÖ Infrastructure deployed"

  # Fast deployment for HTML updates
  deploy-projects:
    needs: detect-changes
    if: needs.detect-changes.outputs.projects != ''
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name == 'master' && 'production' || 'staging' }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install dependencies
        run: npm ci

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy new projects to infrastructure
        shell: bash
        run: |
          echo "Deploying new projects to CloudFront distribution..."
          cd infra
          npm ci --omit=dev
          npm install -g aws-cdk typescript ts-node
          
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          PROJECTS="${{ needs.detect-changes.outputs.projects }}"
          PROJECTS_COMMA=$(echo "$PROJECTS" | tr ' ' ',' | sed 's/,*$//' | sed 's/^,*//')
          
          echo "üîç Checking which projects need infrastructure..."
          CDK_DEFAULT_ACCOUNT=$ACCOUNT_ID CDK_DEFAULT_REGION=us-east-1 \
          npx cdk deploy --context "projects=$PROJECTS_COMMA" \
            --require-approval never --verbose || echo "Some projects may already exist"
          
          echo "‚úÖ Project infrastructure ready"

      - name: Build projects
        shell: bash
        run: |
          echo "üî® Building projects..."
          IFS=' ' read -ra PROJ_ARR <<< "${{ needs.detect-changes.outputs.projects }}"
          for project in "${PROJ_ARR[@]}"; do
            if [ -n "$project" ] && [ -d "projects/$project" ]; then
              echo "Building project: $project"
              PROJECT=$project npx vite build
              echo "‚úÖ Built $project"
            fi
          done

      - name: Sync built sites to S3 (incremental)
        shell: bash
        run: |
          echo "üì§ Syncing built sites to S3..."
          IFS=' ' read -ra PROJ_ARR <<< "${{ needs.detect-changes.outputs.projects }}"
          for project in "${PROJ_ARR[@]}"; do
            if [ -n "$project" ]; then
              echo "Syncing $project to S3..."
              _project=$(echo "$project" | tr '[:upper:]' '[:lower:]')
              
              if [ -d "$BUILD_DIR/$project" ]; then
                # Use incremental sync (no --delete flag for faster uploads)
                # Only upload changed files
                aws s3 sync "$BUILD_DIR/$project" "s3://$S3_BUCKET/$_project" \
                  --region eu-south-2 \
                  --exclude ".*" \
                  --metadata "deployment-date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
                
                echo "‚úÖ Synced $project to S3"
              else
                echo "‚ö†Ô∏è Build directory $BUILD_DIR/$project not found"
              fi
            fi
          done

      - name: Invalidate CloudFront cache (selective)
        shell: bash
        run: |
          echo "üîÑ Invalidating CloudFront cache for changed files..."
          DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
            --region us-east-1 \
            --stack-name MultiTenantDistribution \
            --query 'Stacks[0].Outputs[?OutputKey==`DistributionId`].OutputValue' \
            --output text 2>/dev/null)
          
          if [ -z "$DISTRIBUTION_ID" ] || [ "$DISTRIBUTION_ID" == "None" ]; then
            echo "‚ö†Ô∏è Could not find distribution ID, skipping cache invalidation"
            exit 0
          fi
          
          echo "Distribution ID: $DISTRIBUTION_ID"
          
          # Invalidate all index.html files and common asset patterns
          # This is more efficient than invalidating /* for every update
          aws cloudfront create-invalidation \
            --distribution-id "$DISTRIBUTION_ID" \
            --paths "/*/*/index.html" "/*/*/css/*" "/*/*/js/*" "/*/*/images/*" \
            --output table
          
          echo "‚úÖ Cache invalidation initiated"

      - name: Deployment Summary
        shell: bash
        run: |
          echo "üéâ Deployment Summary"
          echo "===================="
          echo "Deployed projects: ${{ needs.detect-changes.outputs.projects }}"
          echo "Total projects: $(echo '${{ needs.detect-changes.outputs.projects }}' | wc -w)"
          echo ""
          echo "üåê Access your sites at:"
          IFS=' ' read -ra PROJ_ARR <<< "${{ needs.detect-changes.outputs.projects }}"
          for project in "${PROJ_ARR[@]}"; do
            if [ -n "$project" ]; then
              echo "  ‚Ä¢ https://$project.e-info.click"
            fi
          done
          echo ""
          echo "üìä S3 bucket: $S3_BUCKET"
          echo "üåç CloudFront: d27y4ufegjw8rd.cloudfront.net"
